#include <iostream>
#include <string>

template <typename T>
class PRDList {
    private:
    struct BaseNode {
        BaseNode* next_;
};
    struct ListNode : public BaseNode {
        T val_;
        ListNode(T val) : val_(val), next_(nullptr) {} 
        
        
        void dump(std::ostream& os) const {
            os << val_;
            ListNode *next = next_;
            while (next) {
                os << " " << next->val_;
                next = next->next_;
            }
            return;
        }
    };
    private:
    BaseNode* head_;
    private:
    template <typename Iter>
    class listIterator {
        friend PRDList;
        public:
        typedef Iter iterator_type;
        typedef std::forward_iterator_tag iterator_category; // Добавляем синонимы
        typedef ptrdiff_t difference_type; // Корректно вычислять расстояние между 
        typedef T value_type;
        typedef T& reference; // ссылка
        typedef iterator_type* pointer; // указатель
        
        pointer p_value_;
        private:
        listIterator(pointer p) : p_value_(p) {};
        public:
        listIterator(const listIterator& rhs) : p_value(rhs.p_value_) {};
        listIterator(const listIterator&& rhs) {std::swap(p_value_; rhs.p_value_);}
        bool operator==(const listIterator& rhs) const noexcept {return p_value_ == rhs.p_value_;}
        bool operator!=(const listIterator& rhs) const noexcept {return p_value_ != rhs.p_value_;}
        reference operator*() const noexcept {return static_cast<ListNode*>(p_value_)->val_;}
        listIterator& operator++() {p_value_ = p_value_->next_; return *this;}
        listIterator operator++(int) {
            listIterator tmp = *this;
            ++(*this);
            return tmp;
        }
    };
public:
    PRDList() : head_(new BaseNode){}

    typedef listIterator<BaseNode> iterator;
    typedef listIterator<const BaseNode> const_iterator;

    const_iterator begin()  { return const_iterator(head_); }
    const_iterator end()  {
        auto current = head_;
        while (current->next_)
            current = current->next_;
            return const_iterator{current};
    }

    iterator push_front(const T& value) {
        ListNode* node = new ListNode(value);
        node->next_ = head_;
        head_ = node;
        return iterator{head_};
    }

    iterator push_back(const T& value) {
        
    }
};
