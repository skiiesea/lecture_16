#include <iostream>

// Предварительное объявление weak_ptr
template<typename T>
class weak_ptr;

template<typename T>
class shared_ptr {
private:
    T* ptr = nullptr;
    struct ControlBlock {
        size_t shared_count = 0;
        size_t weak_count = 0;
    };
    ControlBlock* control = nullptr;

    void cleanup() {
        if (control) {
            --control->shared_count;
            if (control->shared_count == 0) {
                delete ptr;
                ptr = nullptr;
                
                if (control->weak_count == 0) {
                    delete control;
                    control = nullptr;
                }
            }
        }
    }

public:
    // Конструкторы
    shared_ptr() = default;
    
    explicit shared_ptr(T* raw_ptr) : ptr(raw_ptr) {
        if (raw_ptr) {
            control = new ControlBlock();
            control->shared_count = 1;
        }
    }
    
    // Конструктор из weak_ptr
    shared_ptr(const weak_ptr<T>& weak);
    
    // Копирующий конструктор
    shared_ptr(const shared_ptr& other) : ptr(other.ptr), control(other.control) {
        if (control) {
            ++control->shared_count;
        }
    }
    
    // Перемещающий конструктор
    shared_ptr(shared_ptr&& other) noexcept : ptr(other.ptr), control(other.control) {
        other.ptr = nullptr;
        other.control = nullptr;
    }
    
    // Деструктор
    ~shared_ptr() {
        cleanup();
    }
    
    // Копирующее присваивание
    shared_ptr& operator=(const shared_ptr& other) {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            control = other.control;
            if (control) {
                ++control->shared_count;
            }
        }
        return *this;
    }
    
    // Перемещающее присваивание
    shared_ptr& operator=(shared_ptr&& other) noexcept {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            control = other.control;
            other.ptr = nullptr;
            other.control = nullptr;
        }
        return *this;
    }
    
    // operator bool
    explicit operator bool() const noexcept {
        return ptr != nullptr;
    }
    
    // get
    T* get() const noexcept {
        return ptr;
    }
    
    // swap
    void swap(shared_ptr& other) noexcept {
        std::swap(ptr, other.ptr);
        std::swap(control, other.control);
    }
    
    // reset
    void reset() noexcept {
        cleanup();
    }
    
    void reset(T* raw_ptr) {
        cleanup();
        if (raw_ptr) {
            ptr = raw_ptr;
            control = new ControlBlock();
            control->shared_count = 1;
        }
    }
    
    // use_count
    size_t use_count() const noexcept {
        return control ? control->shared_count : 0;
    }
    
    // unique
    bool unique() const noexcept {
        return use_count() == 1;
    }
    
    // Операторы разыменования
    T& operator*() const noexcept {
        return *ptr;
    }
    
    T* operator->() const noexcept {
        return ptr;
    }
    
    // Операторы сравнения
    bool operator==(const shared_ptr& other) const noexcept {
        return ptr == other.ptr;
    }
    
    bool operator!=(const shared_ptr& other) const noexcept {
        return ptr != other.ptr;
    }
    
    bool operator<(const shared_ptr& other) const noexcept {
        return ptr < other.ptr;
    }
    
    bool operator>(const shared_ptr& other) const noexcept {
        return ptr > other.ptr;
    }
    
    bool operator<=(const shared_ptr& other) const noexcept {
        return ptr <= other.ptr;
    }
    
    bool operator>=(const shared_ptr& other) const noexcept {
        return ptr >= other.ptr;
    }
    
    // Дружественные классы
    template<typename U>
    friend class weak_ptr;
    
    template<typename U, typename... Args>
    friend shared_ptr<U> make_shared(Args&&... args);
};

template<typename T>
class weak_ptr {
private:
    T* ptr = nullptr;
    typename shared_ptr<T>::ControlBlock* control = nullptr;

    void cleanup() {
        if (control) {
            --control->weak_count;
            if (control->shared_count == 0 && control->weak_count == 0) {
                delete control;
            }
            control = nullptr;
        }
        ptr = nullptr;
    }

public:
    // Конструкторы
    weak_ptr() = default;
    
    weak_ptr(const shared_ptr<T>& shared) : ptr(shared.ptr), control(shared.control) {
        if (control) {
            ++control->weak_count;
        }
    }
    
    // Копирующий конструктор
    weak_ptr(const weak_ptr& other) : ptr(other.ptr), control(other.control) {
        if (control) {
            ++control->weak_count;
        }
    }
    
    // Перемещающий конструктор
    weak_ptr(weak_ptr&& other) noexcept : ptr(other.ptr), control(other.control) {
        other.ptr = nullptr;
        other.control = nullptr;
    }
    
    // Деструктор
    ~weak_ptr() {
        cleanup();
    }
    
    // Копирующее присваивание
    weak_ptr& operator=(const weak_ptr& other) {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            control = other.control;
            if (control) {
                ++control->weak_count;
            }
        }
        return *this;
    }
    
    // Присваивание из shared_ptr
    weak_ptr& operator=(const shared_ptr<T>& shared) {
        cleanup();
        ptr = shared.ptr;
        control = shared.control;
        if (control) {
            ++control->weak_count;
        }
        return *this;
    }
    
    // Перемещающее присваивание
    weak_ptr& operator=(weak_ptr&& other) noexcept {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            control = other.control;
            other.ptr = nullptr;
            other.control = nullptr;
        }
        return *this;
    }
    
    // expired
    bool expired() const noexcept {
        return !control || control->shared_count == 0;
    }
    
    // lock
    shared_ptr<T> lock() const noexcept {
        if (expired()) {
            return shared_ptr<T>();
        }
        return shared_ptr<T>(*this);
    }
    
    // use_count
    size_t use_count() const noexcept {
        return control ? control->shared_count : 0;
    }
    
    // swap
    void swap(weak_ptr& other) noexcept {
        std::swap(ptr, other.ptr);
        std::swap(control, other.control);
    }
    
    // reset
    void reset() noexcept {
        cleanup();
    }
};

// Определение конструктора shared_ptr из weak_ptr (после объявления weak_ptr)
template<typename T>
shared_ptr<T>::shared_ptr(const weak_ptr<T>& weak) {
    if (!weak.expired()) {
        ptr = weak.ptr;
        control = weak.control;
        if (control) {
            ++control->shared_count;
        }
    }
}

// Функция make_shared
template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args) {
    shared_ptr<T> result;
    result.ptr = new T(std::forward<Args>(args)...);
    result.control = new typename shared_ptr<T>::ControlBlock();
    result.control->shared_count = 1;
    return result;
}

// Пример использования
struct Test {
    int value;
    Test(int v) : value(v) {
        std::cout << "Test(" << value << ") constructed\n";
    }
    ~Test() {
        std::cout << "Test(" << value << ") destroyed\n";
    }
};

int main() {
    // Тестирование shared_ptr
    auto sp1 = make_shared<Test>(42);
    std::cout << "use_count: " << sp1.use_count() << std::endl;
    std::cout << "unique: " << sp1.unique() << std::endl;
    
    {
        auto sp2 = sp1;
        std::cout << "use_count after copy: " << sp1.use_count() << std::endl;
        std::cout << "unique: " << sp1.unique() << std::endl;
    }
    
    std::cout << "use_count after scope: " << sp1.use_count() << std::endl;
    
    // Тестирование weak_ptr
    weak_ptr<Test> wp = sp1;
    std::cout << "weak_ptr use_count: " << wp.use_count() << std::endl;
    std::cout << "weak_ptr expired: " << wp.expired() << std::endl;
    
    if (auto locked = wp.lock()) {
        std::cout << "Locked value: " << locked->value << std::endl;
    }
    
    sp1.reset();
    std::cout << "weak_ptr expired after reset: " << wp.expired() << std::